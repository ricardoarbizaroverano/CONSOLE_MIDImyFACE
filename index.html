<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MIDImyFACE Console</title>
<style>
:root{
  --bg:#041a3a; --fg:#bfe8ff; --hi:#00ffd5; --dim:#7fb3ff; --line:#0b2f63;
  --led-ok:#12e07d; --led-bad:#ff5670; --led-warn:#ffd44a;
  --bar-on-start: var(--hi); --bar-on-end:#23ff8a; --bar-off:#20406f;
}
html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--fg);font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;letter-spacing:.2px;-webkit-font-smoothing:antialiased}
header{padding:10px 12px;border-bottom:1px solid var(--line);display:flex;align-items:center;gap:10px}
.hbrand{color:var(--hi);font-weight:700}
.box{border:1px solid var(--line)}
.btn,select,input{background:#07224a;color:var(--fg);border:1px solid var(--line);padding:8px 10px;font-family:inherit;font-size:14px}
.btn{cursor:pointer}
.btn:focus,input:focus,select:focus{outline:1px solid var(--hi)}
.kv{display:flex;align-items:center;gap:6px;padding:6px 8px;border:1px solid var(--line)}
.k{color:var(--dim);font-size:12px}
.v{font-weight:700}
.grid{display:grid;gap:10px}
.card .grid{grid-template-columns:repeat(3,minmax(0,1fr))}
.hidden{display:none !important}
.wrap{max-width:1100px;margin:0 auto;padding:12px}
.center{max-width:520px;margin:40px auto}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.grow{flex:1}
.led{width:10px;height:10px;border-radius:50%;background:#2b4b87;display:inline-block}
.led.ok{background:var(--led-ok)} .led.warn{background:var(--led-warn)} .led.bad{background:var(--led-bad)}
.hr{height:1px;background:var(--line);margin:10px 0}
.rack{display:grid;gap:12px;grid-template-columns:repeat(auto-fit,minmax(360px,1fr))}
.card{padding:12px; min-width:360px}
.ct{display:flex;align-items:center;gap:8px;margin-bottom:8px; flex-wrap:wrap}
.ct .nm{font-weight:700; max-width:45%; overflow:hidden; text-overflow:ellipsis; white-space:nowrap}
.small{font-size:12px;color:var(--dim)}
.badge{border:1px solid var(--line);padding:2px 6px;font-size:12px}
.mini{font-size:12px}
.rowx{display:flex;gap:6px;align-items:center}
.gbox{border:1px dashed var(--line);padding:6px}
.gname{display:flex;justify-content:space-between;align-items:center;font-size:12px;color:var(--dim)}
.meter{height:6px;background:#05224a;border:1px solid var(--line);margin-top:4px}
.mbar{height:100%;width:0%}
.mbar.active{background:linear-gradient(90deg,var(--bar-on-start),var(--bar-on-end))}
.mbar.inactive{background:var(--bar-off)}
.tog{padding:3px 6px;border:1px solid var(--line);background:#062149;color:var(--fg);cursor:pointer;font-size:12px}
.tog.active{outline:1px solid var(--hi)}
.noteled{width:9px;height:9px;background:#203b72;display:inline-block}
.noteled.on{background:var(--hi)}
.warnbar{border:1px solid var(--line);padding:6px 8px;color:var(--led-warn)}
/* highlight the routed gesture inside a performer card */
.gbox.active{ outline:1px solid var(--hi); border-radius:6px; }
</style>
</head>
<body>
<header class="wrap">
  <div class="hbrand">MIDImyFACE Console</div>
  <div class="grow"></div>
  <div class="kv"><span class="k">WS</span><span id="kvWS" class="v small">disconnected</span><span id="ledWS" class="led"></span></div>
  <div class="kv"><span class="k">RTT</span><span id="kvRTT" class="v small">—</span></div>
</header>

<!-- AUTH -->
<section id="auth" class="wrap center box" style="padding:12px">
  <div class="grid" style="grid-template-columns:1fr 1fr">
    <div><div class="k">Session ID</div><input id="sid" placeholder="e.g. abc123" /></div>
    <div><div class="k">Password</div><input id="pwd" type="password" placeholder="optional" /></div>
  </div>
  <div class="row" style="margin-top:10px">
    <div class="grow"></div><button id="join" class="btn">JOIN NOW</button>
  </div>
</section>

<!-- MAIN -->
<section id="main" class="wrap hidden">
  <div class="box" style="padding:8px">
    <div class="row">
      <div class="kv"><span class="k">Session</span><span id="kvSession" class="v">—</span></div>
      <div class="kv"><span class="k">Participants</span><span id="kvCount" class="v">0</span></div>
      <div class="grow"></div>
      <div class="kv"><span class="k">MIDI Out (Notes)</span><select id="midiOutNotes"></select></div>
      <div class="kv"><span class="k">CC Out</span><select id="midiOutCC"></select></div>

      <!-- Route gesture (global override for CC source) -->
      <div class="kv">
        <span class="k">Route gesture</span>
        <select id="routeGestureSelect">
          <option value="mouth">Mouth</option>
          <option value="smile">Smile</option>
          <option value="leftWink">Left Wink</option>
          <option value="rightWink">Right Wink</option>
          <option value="noseX">Nose X</option>
          <option value="noseY">Nose Y</option>
        </select>
      </div>

      <button id="ping" class="btn mini">PING</button>
      <button id="panic" class="btn mini">PANIC</button>
    </div>
  </div>

  <div class="hr"></div>
  <div id="warn" class="warnbar hidden">Web MIDI unavailable. Use Chrome/Edge and select a virtual MIDI port (IAC / loopMIDI).</div>
  <div id="rack" class="rack"></div>
  <div class="hr"></div>
  <div class="row small">
    <div>In: <b id="tpIn">0</b>/s</div><div>Out: <b id="tpOut">0</b>/s</div>
    <div class="grow"></div><div id="status" class="small">ready</div>
  </div>
</section>

<!-- Tone.js for local monitor -->
<script src="https://cdn.jsdelivr.net/npm/tone@14.8.49/build/Tone.min.js" defer></script>

<script>
/* ===== Relay URL (hard-coded, not shown in UI) ===== */
const RELAY_URL_DEFAULT = "wss://midimyface-relay.onrender.com/ws";
const qs = new URLSearchParams(location.search);
const RELAY_URL = qs.get('ws') || localStorage.getItem('relayURL') || RELAY_URL_DEFAULT;

/* ===== Instruments for local monitor (very light) ===== */
const INSTRUMENTS = {
  musicBox: { urls: { A3:"https://cdn.freesound.org/previews/9/9276_1407-lq.mp3" } },
  piano:    { urls: { C4:"https://cdn.freesound.org/previews/83/83114_95830-lq.mp3" }, release:1 },
  pad:      { urls: { A3:"https://cdn.freesound.org/previews/636/636873_5544184-lq.mp3" }, release:1 },
  flauta:   { urls: { C4:"https://cdn.freesound.org/previews/654/654712_11532701-lq.mp3" }, release:1 },
  marimba:  { urls: { A3:"https://cdn.freesound.org/previews/577/577688_4617272-lq.mp3" } },
  strings:  { urls: { A3:"https://cdn.freesound.org/previews/374/374588_2475994-lq.mp3" }, release:1 },
  trumpet:  { urls: { G3:"https://cdn.freesound.org/previews/487/487480_7295656-lq.mp3" }, release:1 }
};
function midiToNoteName(n){ const N=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];const o=Math.floor(n/12)-1,i=n%12;return N[i]+o; }

/* ===== Gesture maps & labels (Console side) ===== */
const GESTURE_FROM_CH = {1:"mouth",2:"smile",3:"leftWink",4:"rightWink",5:"noseX",6:"noseY"};
const GESTURE_LABEL   = {mouth:"Mouth",smile:"Smile",leftWink:"Left Wink",rightWink:"Right Wink",noseX:"Nose X",noseY:"Nose Y"};
const ALL_GESTURES    = ["mouth","smile","leftWink","rightWink","noseX","noseY"];

/* ===== Global routed gesture (override) ===== */
let routedGesture = "mouth";
const routeGestureSelect = document.getElementById("routeGestureSelect");
if (routeGestureSelect) {
  routeGestureSelect.value = routedGesture;
  routeGestureSelect.addEventListener("change", () => {
    routedGesture = routeGestureSelect.value;
    console.log("[console] routing gesture =", routedGesture);
  });
}

/* ===== Default CC numbers per gesture ===== */
const DEFAULT_CC_FOR_GESTURE = {
  mouth:11,   // Expression
  smile:1,    // Modulation
  leftWink:74,// Brightness
  rightWink:71,// Resonance
  noseX:10,   // Pan
  noseY:91    // Reverb
};

/* ===== DOM helpers & state ===== */
const el = id => document.getElementById(id);
const $auth = el('auth'), $main = el('main'), $rack = el('rack');
function clamp(v,min,max){ return Math.max(min,Math.min(max,v)); }

let ws=null, wsConnected=false, pingTimer=null, lastPing=0;
let sessionId="", password="", reconnectTimer=null, reconnectAttempts=0, shouldStayConnected=false;
let participants = new Map();
let midi=null;
let notesOutId=null, ccOutId=null;
let tpIn=0, tpOut=0;
setInterval(()=>{ el('tpIn').textContent=tpIn; el('tpOut').textContent=tpOut; tpIn=0; tpOut=0; },1000);

/* ===== UI bits ===== */
function setWS(state){ wsConnected=(state==='connected'); el('kvWS').textContent=state; el('ledWS').className='led '+(state==='connected'?'ok':state==='connecting'?'warn':state==='error'?'bad':''); }
function setRTT(ms){ el('kvRTT').textContent=ms?((ms|0)+' ms'):'—'; }
function setStatus(s){ el('status').textContent=s; }
function updateCount(){
  const fromState = [...participants.values()].filter(p=>p.connected).length;
  const fromDom   = document.querySelectorAll('#rack [data-id]').length;
  el('kvCount').textContent = Math.max(fromState, fromDom);
}

/* ===== Model ===== */
function makePerformer(id, name){
  const gestures={}; ALL_GESTURES.forEach(g=> gestures[g]={value:0, route:true, mute:false, solo:false});
  return {
    id, name, connected:true,
    assignedOutChannel:1, mute:false, solo:false, notesRoute:true,
    noteSource:"mouth", velocitySource:"fixed", velocityFixed:100,
    ccFallbackSource:"noseX",
    lastCCNumber: DEFAULT_CC_FOR_GESTURE["noseX"],
    gestures,
    lastNote:{on:false,note:60,vel:100},
    lastGesture:"—",
    audio:{on:false, instrument:"musicBox", gain:null, sampler:null, volume:0.8, ready:false}
  };
}
function ensurePerf(id, name){
  if(!participants.has(id)){ const p=makePerformer(id,name||("P-"+id)); participants.set(id,p); renderCard(p,true); updateCount(); }
  return participants.get(id);
}
function anySolo(){
  for(const p of participants.values()){
    if(p.solo) return true;
  }
  return false;
}
function routable(p,g){
  const gg=p.gestures[g]; if(p.mute||gg.mute) return false;
  const solo=anySolo(); return solo ? (p.solo||gg.solo)&&gg.route : gg.route;
}

/* Performer-level gates */
function notesRoutable(p){
  if (p.mute) return false;
  const solo = anySolo();
  return solo ? p.solo : p.notesRoute;
}
function ccRoutable(p){
  if (p.mute) return false;
  const solo = anySolo();
  return solo ? p.solo : true;
}

/* Choose CC source gesture for a performer:
   - If global routedGesture is set, use it
   - Else if any gesture has Solo, use the first such gesture
   - Else fallback (noseX) */
function pickCCSourceGesture(p){
  if (routedGesture && ALL_GESTURES.includes(routedGesture)) return routedGesture;
  const sol = ALL_GESTURES.find(g => p.gestures[g]?.solo);
  return sol || p.ccFallbackSource || "noseX";
}
function ccNumberForGesture(g){
  return DEFAULT_CC_FOR_GESTURE[g] ?? 11;
}

/* ===== MIDI out helpers ===== */
function getOutById(id){ return (midi && id) ? midi.outputs.get(id) : null; }
function st(base,ch){ return (base | ((clamp(ch,1,16)-1)&0x0F)); }
function sendNote(on,n,vel,ch){
  const out = getOutById(notesOutId);
  if(!out) return;
  out.send([ st(on?0x90:0x80,ch), clamp(n,0,127), clamp(vel,0,127) ]); tpOut++;
}
function sendCC_Perf(p,val){
  const out = getOutById(ccOutId);
  if(!out) return;
  const g = pickCCSourceGesture(p);
  const ccNum = ccNumberForGesture(g);
  out.send([ st(0xB0, p.assignedOutChannel), clamp(ccNum,0,127), clamp(val,0,127) ]); tpOut++;
}

/* ===== Local monitor (Tone.js) ===== */
async function ensureAudioNodes(p){
  if (typeof Tone === 'undefined') {
    console.warn('[Console] Tone.js not loaded yet; skipping local monitor init');
    return;
  }
  if (Tone.context.state !== 'running') {
    try { await Tone.start(); } catch(e) { console.warn('Tone.start() blocked:', e); }
  }
  if (p.audio.ready) return;
  if (!p.audio.gain) { p.audio.gain = new Tone.Gain(p.audio.volume).toDestination(); }
  await swapInstrument(p, p.audio.instrument);
  p.audio.ready = true;
}
async function swapInstrument(p, name){
  p.audio.instrument = name;
  if(p.audio.sampler){ try{ p.audio.sampler.dispose(); }catch{} p.audio.sampler=null; }
  const def = INSTRUMENTS[name] || INSTRUMENTS.musicBox;
  p.audio.sampler = new Tone.Sampler({ urls:def.urls, release:def.release||0.3, onload:()=>{} }).connect(p.audio.gain);
}
function playLocal(p, note, vel, on){
  if(!p.audio.on || !p.audio.sampler) return;
  const nName = midiToNoteName(note);
  const now = Tone.now();
  const v = clamp(vel/127, 0, 1);
  if(on){ p.audio.sampler.triggerAttack(nName, now, v || 0.8); }
  else  { p.audio.sampler.triggerRelease(nName, now); }
}

/* ===== Render ===== */
function renderCard(p, fresh=false){
  let card = document.querySelector(`[data-id="${p.id}"]`);
  if(!card){
    card = document.createElement('div');
    card.className = 'card box';
    card.dataset.id = p.id;
    card.innerHTML = `
      <div class="ct">
        <span class="led ${p.connected?'ok':''}" data-led></span>
        <span class="nm">${p.name||p.id}</span>
        <span class="badge mini" style="margin-left:8px">Last</span>
        <span class="badge mini" data-lastg>—</span>
        <span class="grow"></span>
        <span class="badge">ChOut</span>
        <select data-ch>${Array.from({length:16},(_,i)=>`<option value="${i+1}">${i+1}</option>`).join('')}</select>
        <span class="badge">Note</span>
        <span class="noteled" data-noteled></span>
        <button class="tog" data-notes>Route</button>
        <button class="tog" data-m>M</button>
        <button class="tog" data-s>S</button>
      </div>

      <div class="row small" style="gap:8px;align-items:center;margin:-2px 0 6px 0">
        <span class="badge">Sound</span>
        <button class="tog" data-audio>OFF</button>
        <select data-ins>${Object.keys(INSTRUMENTS).map(k=>`<option value="${k}">${k}</option>`).join('')}</select>
        <input type="range" min="0" max="1" step="0.01" value="${p.audio?.volume ?? 0.8}" class="mini" style="width:110px" data-vol />
      </div>

      <div class="grid" style="grid-template-columns:1fr 1fr 1fr; gap:6px">
        ${ALL_GESTURES.map(g=>`
          <div class="gbox" data-gesture="${g}">
            <div class="gname"><span>${GESTURE_LABEL[g]}</span><span class="led" data-ledg="${g}"></span></div>
            <div class="meter"><div class="mbar ${p.gestures[g].route?'active':'inactive'}" data-bar="${g}" style="width:0%"></div></div>
            <div class="rowx">
              <button class="tog" data-r="${g}">Route</button>
              <button class="tog" data-gm="${g}">M</button>
              <button class="tog" data-gs="${g}">S</button>
              <div class="small">v=<span data-v="${g}">0</span></div>
            </div>
          </div>
        `).join('')}
      </div>
    `;
    $rack.appendChild(card);

    /* wire up */
    const chSel   = card.querySelector('[data-ch]');
    const btnNotes= card.querySelector('[data-notes]');
    const btnM    = card.querySelector('[data-m]');
    const btnS    = card.querySelector('[data-s]');
    const btnAudio= card.querySelector('[data-audio]');
    const selIns  = card.querySelector('[data-ins]');
    const vol     = card.querySelector('[data-vol]');

    chSel.value = p.assignedOutChannel;
    btnNotes.classList.toggle('active', p.notesRoute);
    btnM.classList.toggle('active', p.mute);
    btnS.classList.toggle('active', p.solo);
    btnAudio.textContent = p.audio.on ? "ON" : "OFF";
    btnAudio.classList.toggle('active', p.audio.on);
    selIns.value = p.audio.instrument;

    chSel.onchange   = ()=>{ p.assignedOutChannel = parseInt(chSel.value,10)||1; };
    btnNotes.onclick = ()=>{ p.notesRoute=!p.notesRoute; btnNotes.classList.toggle('active',p.notesRoute); };
    btnM.onclick     = ()=>{ p.mute=!p.mute; btnM.classList.toggle('active',p.mute); };
    btnS.onclick     = ()=>{ p.solo=!p.solo; btnS.classList.toggle('active',p.solo); };

    btnAudio.onclick = async ()=>{
      p.audio.on = !p.audio.on;
      btnAudio.textContent = p.audio.on ? "ON" : "OFF";
      btnAudio.classList.toggle('active', p.audio.on);
      if (p.audio.on) {
        await ensureAudioNodes(p);
        if (typeof Tone !== 'undefined' && p.audio.gain) {
          p.audio.gain.gain.setValueAtTime(p.audio.volume, Tone.now());
        }
      }
    };

    selIns.onchange = async ()=>{
      p.audio.instrument = selIns.value;
      if(p.audio.on){ await ensureAudioNodes(p); await swapInstrument(p, p.audio.instrument); }
    };
    vol.oninput = ()=>{
      const v=parseFloat(vol.value||"0.8"); p.audio.volume=v;
      if(p.audio.gain) p.audio.gain.gain.setValueAtTime(v, Tone.now());
    };

    ALL_GESTURES.forEach(g=>{
      const r   = card.querySelector(`[data-r="${g}"]`);
      const gm  = card.querySelector(`[data-gm="${g}"]`);
      const gs  = card.querySelector(`[data-gs="${g}"]`);
      const bar = card.querySelector(`[data-bar="${g}"]`);
      r.classList.toggle('active', p.gestures[g].route);
      gm.classList.toggle('active', p.gestures[g].mute);
      gs.classList.toggle('active', p.gestures[g].solo);
      r.onclick  = ()=>{ p.gestures[g].route=!p.gestures[g].route; r.classList.toggle('active',p.gestures[g].route); bar.classList.toggle('active',p.gestures[g].route); bar.classList.toggle('inactive',!p.gestures[g].route); };
      gm.onclick = ()=>{ p.gestures[g].mute=!p.gestures[g].mute; gm.classList.toggle('active',p.gestures[g].mute); };
      gs.onclick = ()=>{ p.gestures[g].solo=!p.gestures[g].solo; gs.classList.toggle('active',p.gestures[g].solo); };
    });
  }
  card.querySelector('[data-led]').className = 'led ' + (p.connected?'ok':'');
  const last = card.querySelector('[data-lastg]'); if(last) last.textContent = p.lastGesture || '—';
}

/* ===== UI updates ===== */
function noteLED(id,on){
  const card=document.querySelector(`[data-id="${id}"]`); if(!card) return;
  const n=card.querySelector('[data-noteled]'); if(!n) return;
  if(on){ n.classList.add('on'); setTimeout(()=>n.classList.remove('on'),120); }
}
function updateGestureUI(id,g,value){
  const card=document.querySelector(`[data-id="${id}"]`); if(!card) return;
  const bar=card.querySelector(`[data-bar="${g}"]`);
  if(bar) bar.style.width = (clamp(value,0,127)/127*100)+'%';
  const vEl=card.querySelector(`[data-v="${g}"]`); if(vEl) vEl.textContent=clamp(value,0,127);
  const ledg=card.querySelector(`[data-ledg="${g}"]`); if(ledg){ ledg.className='led ok'; setTimeout(()=>ledg.className='led',80); }

  // highlight whichever gesture is currently routed for this performer
  const p = participants.get(id);
  if (p) {
    const active = pickCCSourceGesture(p);
    card.querySelectorAll('.gbox[data-gesture]').forEach(el=>{
      el.classList.toggle('active', el.getAttribute('data-gesture') === active);
    });
  }
}

/* ===== Message handling (host side) ===== */
function handleRelayMessage(m){
  switch(m.type){
    case "joined": return;

    case "session/roster": {
      (m.data||[]).forEach(row=>{
        const p=ensurePerf(row.participant_id,row.name);
        p.connected=true; if(row.channel) p.assignedOutChannel=row.channel; renderCard(p);
      });
      updateCount(); return;
    }
    case "session/joined": {
      const d=m.data||{}; const p=ensurePerf(d.participant_id,d.name);
      p.connected=true; if(d.channel) p.assignedOutChannel=d.channel; renderCard(p,true); updateCount(); return;
    }
    case "session/left": {
      const d = m.data || {};
      const p = participants.get(d.participant_id);
      if (p) {
        participants.delete(d.participant_id);
        const card = document.querySelector(`[data-id="${d.participant_id}"]`);
        if (card && card.parentNode) card.parentNode.removeChild(card);
      }
      updateCount();
      return;
    }

    case "midi/cc": {
      const d=m.data||{}; const p=ensurePerf(d.from,d.name);
      const gkey = d.name && ALL_GESTURES.includes(d.name) ? d.name : GESTURE_FROM_CH[d.channel];
      if(gkey){
        const val = d.value|0;
        p.gestures[gkey].value = val;
        p.lastGesture = gkey;
        renderCard(p);
        updateGestureUI(p.id,gkey,val);

        // route only from the picked CC source for this performer
        if (ccRoutable(p)){
          const src = pickCCSourceGesture(p);
          if (src === gkey) sendCC_Perf(p, val);
        }
      }
      return;
    }

    case "gesture/update": {
      const d=m.data||{}; const p=ensurePerf(d.from,d.name);
      const gkey=d.name; if(ALL_GESTURES.includes(gkey)){
        const val=d.value|0; p.gestures[gkey].value=val; p.lastGesture=gkey; renderCard(p); updateGestureUI(p.id,gkey,val);
      }
      return;
    }

    case "midi/note_on": {
      const d=m.data||{}; const p=ensurePerf(d.from,d.name);
      const note=d.note|0, vel=(d.vel|0)||100;
      p.lastNote={on:true,note,vel}; noteLED(p.id,true);
      if(notesRoutable(p)) sendNote(true,note,vel,p.assignedOutChannel);
      if(p.audio.on){ ensureAudioNodes(p).then(()=> playLocal(p,note,vel,true)); }
      return;
    }
    case "midi/note_off": {
      const d=m.data||{}; const p=ensurePerf(d.from,d.name);
      const note=d.note|0, vel=(d.vel|0)||0;
      noteLED(p.id,false);
      if(notesRoutable(p)) sendNote(false,note,vel,p.assignedOutChannel);
      if(p.audio.on){ playLocal(p,note,vel,false); }
      return;
    }

    case "server/assigned": {
      const d=m.data||{}; const p=ensurePerf(d.participant_id);
      if(d.channel){ p.assignedOutChannel=d.channel; renderCard(p); }
      return;
    }
    default: return;
  }
}

/* ===== WS client ===== */
function connectWS(){
  setWS('connecting');
  try{
    if (ws) { try{ ws.close(); }catch{} ws = null; }
    ws=new WebSocket(RELAY_URL);
  }catch(e){ setWS('error'); setStatus('WS init failed'); return; }

  ws.onopen = ()=>{
    setWS('connected'); setRTT(null); reconnectAttempts=0; clearTimeout(reconnectTimer);
    ws.send(JSON.stringify({ type:"hello", session_id:sessionId, password:password||"", role:"host", name:"Console", client_uuid:null }));
    clearInterval(pingTimer);
    pingTimer=setInterval(()=>{ lastPing=performance.now(); try{ ws.send(JSON.stringify({type:"system/ping",data:{t:Date.now()}})); }catch{} },5000);
  };
  ws.onmessage = (ev)=>{ tpIn++; let m=null; try{ m=JSON.parse(ev.data||"{}"); }catch{return;}
    if(m.type==="system/pong"){ setRTT(performance.now()-lastPing); return; }
    handleRelayMessage(m);
  };
  ws.onerror = ()=> setWS('error');
  ws.onclose  = ()=>{
    setWS('disconnected'); clearInterval(pingTimer);
    if(shouldStayConnected){
      const delay=Math.min(10000,1000*Math.pow(2,reconnectAttempts++));
      const jitter=Math.floor(Math.random()*400);
      clearTimeout(reconnectTimer); reconnectTimer=setTimeout(()=>connectWS(),delay+jitter);
    }
  };
}

/* ===== MIDI init ===== */
function midiInit(){
  if(!('requestMIDIAccess' in navigator)){ el('warn').classList.remove('hidden'); return; }
  navigator.requestMIDIAccess({sysex:false,software:true})
    .then(access=>{ midi=access; midi.onstatechange=buildOuts; buildOuts(); })
    .catch(()=> el('warn').classList.remove('hidden'));
}
function buildOuts(){
  const selNotes=el('midiOutNotes'); const selCC=el('midiOutCC');
  selNotes.innerHTML=''; selCC.innerHTML='';
  const outs=Array.from(midi.outputs.values()).filter(o=>o.state==='connected');

  const ph1=new Option('Select Notes Out…',''); ph1.disabled=true; ph1.selected=!notesOutId; selNotes.add(ph1);
  const ph2=new Option('Select CC Out…',''); ph2.disabled=true; ph2.selected=!ccOutId; selCC.add(ph2);

  outs.forEach(o=> { selNotes.add(new Option(o.name,o.id)); selCC.add(new Option(o.name,o.id)); });

  // auto-pick sensible defaults
  const prefNotes = outs.find(o=>/notes|mmf[- ]?notes|virtual|iac|loopmidi|blackhole|rtpmidi|bus/i.test(o.name)) || outs[0];
  if(!notesOutId && prefNotes){ notesOutId=prefNotes.id; selNotes.value=prefNotes.id; }
  const prefCC = outs.find(o=>o.id!==notesOutId) || outs[0];
  if(!ccOutId && prefCC){ ccOutId=prefCC.id; selCC.value=prefCC.id; }

  selNotes.onchange=()=>{ notesOutId = selNotes.value || null; };
  selCC.onchange   =()=>{ ccOutId    = selCC.value    || null; };
}

/* ===== Buttons ===== */
el('ping').onclick = ()=>{
  if(!notesOutId){ setStatus('Select Notes Out'); return; }
  sendNote(true,60,100,1); setTimeout(()=>sendNote(false,60,0,1),120);
};
el('panic').onclick= ()=>{
  if(!notesOutId){ setStatus('Select Notes Out'); return; }
  const out = getOutById(notesOutId); if(!out){ setStatus('Notes port unavailable'); return; }
  for(let ch=1;ch<=16;ch++){
    out.send([st(0xB0,ch),123,0]); tpOut++; // All Notes Off
    out.send([st(0xB0,ch),120,0]); tpOut++; // All Sound Off
    for(let n=0;n<128;n++){ out.send([st(0x80,ch),n,0]); tpOut++; }
  }
  setStatus('panic sent');
};

/* ===== Wire-up ===== */
el('join').onclick = ()=>{
  sessionId = el('sid').value.trim() || Math.random().toString(36).slice(2,8);
  password  = el('pwd').value;
  el('kvSession').textContent = sessionId;
  $auth.classList.add('hidden'); $main.classList.remove('hidden');
  shouldStayConnected = true;
  connectWS();
};
midiInit();
</script>
</body>
</html>
